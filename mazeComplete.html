<html>
  <style>
    body {
	background-color: #152238;
    }
    .map {
	background-color: #23395d;
	!border: solid 4px blue;
    }
  </style>
  <canvas id='map' class='map'></canvas>
  <script>
    function randInt(max) {
        return Math.floor(Math.random()*max);
    }
    
    class Maze {
	constructor(canvas, size, numberCells, proportionWalls) {
	    this.canvas = canvas;
	    this.ctx = this.canvas.getContext('2d');

	    this.size = size;
	    this.canvas.width =	this.size;
            this.canvas.height = this.size;

	    this.numberCells = numberCells; // on one side
	    this.proportionWalls = proportionWalls;
	    
	    this.cellWidth = this.size/this.numberCells;
	    this.numberCorners = numberCells + 1;
	    
	    this.cornerRadius = 0.1*this.canvas.width/this.numberCorners;
	    this.cornerColor = '#152238';
	    this.playerRadius = 3*this.cornerRadius;
	    this.playerColor = '#4169E1';
	    this.wallWidth = 2*this.cornerRadius;
	    this.wallColor = '#152238';
	    this.pathWidth = this.wallWidth;
	    this.pathColor = 'white';
	    
	    this.cells = {};
	    this.walls = {};
	    this.initializeMaze();
	}
	
	initializeMaze() {
	    this.initializeCells();
	    this.initializePaths();
	    this.initializeWalls();
	}

	initializeWalls() {
	    let paths = Object.keys(this.walls);
	    for (let i = 0; i < this.proportionWalls*paths.length; i++) {
		this.walls[paths[randInt(paths.length)]] = 0;
	    }
	}
	
	initializeCells() {
	    let count = 0;
	    for (let i = 0; i < this.numberCells; i++) {
		for (let j = 0; j < this.numberCells; j++) {
		    this.cells[String(count)]  = [i, j];
		    //this.cells[label]  = [i % this.numberCells, j % this.numberCells];
		    count++;
		}
	    }
	}
	
	initializePath(labelA, labelB) {
	    /*
	      I could check to see if this wall is already initialized, 
	      but I think that could actually be more computationally intensive.
	    */
	    //console.log(labelA, labelB);
	    this.walls[[labelA, labelB].sort().toString()] = 1;
	}
	
	initializePaths() {
	    for (let [label, position] of Object.entries(this.cells)) {
		label = Number(label);
		if (label == 0) {
		    //console.log('top left corner', label)
		    // top left corner cell
		    this.initializePath(label, label + 1); // right
		    this.initializePath(label, label + this.numberCells); // bottom
		} else if (label == this.numberCells - 1) {
		    //console.log('top right corner', label)
		    // top right corner cell
		    this.initializePath(label, label - 1); // left
                    this.initializePath(label, label + this.numberCells); // bottom
		} else if (label == this.numberCells*(this.numberCells - 1)) {
		    //console.log('bottom left corner', label)
		    // bottom left corner cell
		    this.initializePath(label, label + 1); // right
                    this.initializePath(label, label - this.numberCells); // top
		} else if (label == this.numberCells*this.numberCells - 1) {
		    //console.log('bottom right corner', label)
		    // bottom right corner cell
		    this.initializePath(label, label - 1); // left
                    this.initializePath(label, label - this.numberCells); // top
		} else if (label > 0 && label < this.numberCells - 1) {
		    //console.log('top row', label)
		    // top row minus corners
		    this.initializePath(label, label + 1); // right
                    this.initializePath(label, label - 1); // left
		    this.initializePath(label, label + this.numberCells); // bottom
		} else if (label > this.numberCells*(this.numberCells - 1) && label < this.numberCells*this.numberCells - 1) {
		    //console.log('bottom row', label)
		    // bottom row minus corners
		    this.initializePath(label, label + 1); // right
		    this.initializePath(label, label - 1); // left
		    this.initializePath(label, label - this.numberCells ); // top
		} else if (label % this.numberCells == 0) {
		    //console.log('left column', label)
		    // left column minus corners
		    this.initializePath(label, label - this.numberCells); // top
                    this.initializePath(label, label + this.numberCells); // bottom
		    this.initializePath(label, label + 1); // right
		} else if ((label + 1) % this.numberCells == 0) {
		    //console.log('right column', label)
		    // right column minus corners
		    this.initializePath(label, label - this.numberCells); // top
		    this.initializePath(label, label + this.numberCells); // bottom
		    this.initializePath(label, label - 1); // left
		} else {
		    //console.log('middle', label)
		    // in the middle
		    this.initializePath(label, label - 1); // left
		    this.initializePath(label, label + 1); // right
		    this.initializePath(label, label - this.numberCells); // top
		    this.initializePath(label, label + this.numberCells); // bottom
		}
	    }
	}
	
	render(showCorners = false, showPaths = false, showLabels = false) {
	    if (showCorners) {
		this.renderCorners();
	    }

	    if (showPaths) {
		this.renderPaths();
	    }
	    
	    this.renderWalls();

	    if (showLabels) {
		this.renderCellLabels();
	    }
	}

	drawCircle(x, y, circleType) {
            this.ctx.beginPath();
            if (circleType == 'corner') {
                this.ctx.arc(x, y, this.cornerRadius, 0, 2*Math.PI);
                this.ctx.fillStyle = this.cornerColor;
            } else if (circleType == 'player') {
                this.ctx.arc(x, y, this.playerRadius, 0, 2*Math.PI);
                this.ctx.fillStyle = this.playerColor;
            }
            this.ctx.fill();
        }

	renderPaths() {
	    let a, b, c, d;
	    let labelA, labelB;
	    for (let [path, open] of Object.entries(this.walls)) {
		if (open) {
		    [labelA, labelB] = path.split(',');
		    a = this.cells[labelA][0];
		    b = this.cells[labelA][1];
		    c = this.cells[labelB][0];
		    d = this.cells[labelB][1];
		    this.drawLine((a+0.5)*this.cellWidth,
				  (b + 0.5)*this.cellWidth,
				  (c + 0.5)*this.cellWidth,
				  (d + 0.5)*this.cellWidth, 'path');
		}
	    }
	}

	renderCellLabels() {
	    let a, b;
	    this.ctx.font = String(this.size/this.numberCells/5) + "px Arial";
	    for (let [label, position] of Object.entries(this.cells)) {
		a = this.cells[label][0];
                b = this.cells[label][1];
		this.ctx.fillText(String(label), (a + 0.5)*this.cellWidth, (b + 0.5)*this.cellWidth);
	    }
	}

	renderCorners() {
            let x = 0, y = 0;
            for (let i = 0; i < this.numberCorners; i++) {
                x = i*this.cellWidth;
                for (let j = 0; j < this.numberCorners; j++) {
                    y = j*this.cellWidth;
                    this.drawCircle(x, y, 'corner');
                }
            }
        }

	renderWalls() {
	    for (let [path, open] of Object.entries(this.walls)) {		
		if (!open) {
		    this.renderWall(path, 'wall');
		}
	    }
	}

	renderWall(path, lineType) {
	    let [labelA, labelB] = path.split(',');
	    labelA = Number(labelA);
	    labelB = Number(labelB);
	    if (labelA > labelB) {
		let tempLabel = labelA;
		labelA = labelB;
		labelB = tempLabel;
	    }
	    let s = 0.05;
	    let a, b, c, d, x1, y1, x2, y2;
	    a = this.cells[labelA][0];
            b = this.cells[labelA][1];
            c = this.cells[labelB][0];
            d = this.cells[labelB][1];
	    if (a != c) {
		// vertical wall
		x1 = c;
		y1 = b;
		x2 = c;
		y2 = d + 1;
	    } else {
		// horizonal wall
		x1 = a;
                y1 = d;
                x2 = c + 1;
                y2 = d;
	    }
	    this.drawLine(x1*this.cellWidth, y1*this.cellWidth, x2*this.cellWidth, y2*this.cellWidth, lineType);
	}
    
	drawLine(x1, y1, x2, y2, lineType) {
	    this.ctx.beginPath();
            this.ctx.moveTo(x1, y1);
            this.ctx.lineTo(x2, y2);
	    if (lineType == 'wall') {
		this.ctx.lineWidth = this.wallWidth;
		this.ctx.strokeStyle = this.wallColor;
	    } else if (lineType == 'path') {
		this.ctx.lineWidth = this.pathWidth;
                this.ctx.strokeStyle = this.pathColor;
	    } else if (lineType == 'erase wall') {
		this.ctx.lineWidth = this.pathWidth;
                this.ctx.strokeStyle = 'white';
	    }
            this.ctx.stroke();
        }

	flipRandomPath() {
	    let paths = Object.keys(this.walls);
	    let changePath;
	    let i = randInt(paths.length);
	    changePath = paths[i];
	    this.walls[changePath] = !this.walls[changePath];
	}

	clear() {
	    this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
	}
    }

    class Game {
	constructor(canvas) {
	    this.size = 750;
	    this.numberCells = 21;
	    this.proportionWalls = 0.8;
	    this.canvas = document.getElementById('map');

	    this.deltaT = 10;
	    this.iterations = 1000;
	    
	    this.maze = new Maze(this.canvas, this.size, this.numberCells, this.proportionWalls);

	    this.render();
	}

	render() {
	    this.maze.render();
	}

	play () {
	    let time = 0;
	    for (let i = 0; i < this.iterations; i++) {
		setTimeout(() => {
		    time += this.deltaT/1000;
		    this.maze.flipRandomPath();
		    this.maze.clear();
		    this.maze.render();
		}, i*this.deltaT);
	    }
	}
    }
    
    let game = new Game();
    game.play();
  </script>
</html>
