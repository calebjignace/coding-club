<html>
  <style>
    body {
	background-color: gray;
    }
    .map {
	background-color: white;
	border: solid 4px blue;
    }
  </style>
  <canvas id='map' class='map'></canvas>
  <script>
    function randInt(max) {
        return Math.floor(Math.random()*max);
    }
    
    class Maze {
	constructor(canvas, size, numberCells) {
	    this.canvas = canvas;
	    this.ctx = this.canvas.getContext('2d');

	    this.size = size;
	    this.canvas.width =	this.size;
            this.canvas.height = this.size;

	    this.numberCells = numberCells;
	    this.cellWidth = this.size/this.numberCells;
	    this.numberCorners = numberCells + 1;
	    
	    this.cornerRadius = 0.1*this.canvas.width/this.numberCorners;
	    this.cornerColor = 'red';
	    this.playerRadius = 5*this.cornerRadius;
	    this.playerColor = 'black';
	    this.wallWidth = 0.2*this.canvas.width/this.numberCells;
	    this.wallColor = 'blue';
	    
	    this.cells = {};
	    this.walls = [];
	    this.initializeMaze();
	    this.render(true);
	}
	
	initializeMaze() {
	    this.initializeCells();
	    //this.initializeWalls();
	}
	
	initializeCells() {
	    let count = 0;
	    for (let i = 0; i < this.numberCells; i++) {
		for (let j = 0; j < this.numberCells; j++) {
		    this.cells[[i % this.numberCells, j % this.numberCells]] = count;
		    count++;
		}
	    }
	}
    
	initializeWalls() {
	    for (let count = 0; count < this.numberWalls; count++) {
		this.walls.push(createWall());
	    }
	}

	isCorner(i, j) {
	    // there must be a simpler way to do this, probably with modulo
	    if (i == 0 && j == 0) {
		return true; // north west corner
	    } else if (i == 0 && j == N - 1) {
		return true; // south west corner
	    } else if (i == N - 1 && j == 0) {
		return true; // north east corner
	    } else if (i == N - 1 && j == N - 1) {
		return true; // south west corner
	    } else {
		return false;
	    }
	}

	isSameCell(A, B) {
	    if (A[0] == B[0] && A[1] == B[1]) {
		return true;
	    } else {
		return false;
	    }
	}
	
	isAlreadyWall(w) {
	    // this will be deleted eventually

	    /*
	      Checks to see if w is in set of walls
	      
	      Returns true if
	      w = [[a,b], [c, d]] 
	      e = [[a,b], [c, d]]
	      OR
	      w = [[a,b], [c, d]] 
	      e = [[c, d], [a, b]]

	      Otherwise returns false
	      
	      That is, order of cells doesn't matter,
	      per the definition of edge between vertices.
	    */
	    for (let o of this.walls) {
		if (this.isSameCell(w[0], o[0]) && this.isSameCell(w[1], o[1])) {
		    return true;
		} else if (this.isSameCell(w[0], o[1]) && this.isSameCell(w[1], o[0])) {
		    return true;
		} else {
		    return false;
		}
	    }
	}
	
	mapStillOpen(newWall) {
            if (!newWall) {
		return false;
            }
	}
	
	createWall() {
	    /*
	      Creates a valid wall out of all possible walls.
	      
	      The loop chooses random wall and rejects it if
	      1) it's already in set of walls, or
	      2) it prevents a path from any cell to any other cell
	    */
	    let i1, j1; // first cell
	    let i2, j2; // second cell
	    let potentialWall;
	    let dice;
	    //let start = -1, end = N + 1;
	    let start = 0, end = N - 1;
	    while (true) {
		i1 = randInt(end + 1) + start, j1 = randInt(end) + start;
		//i1 = randInt(end + 1) + start, j1 = randInt(end + 1) + start;
		if (!this.isCorner(i1, j1)) {
		    if (i1 == start) {
			// first cell is on west edge
			// second cell is east of first
			i2 = i1 + 1;
			j2 = j1;
		    } else if (i1 == end) {
			// first cell is on east edge
			// second cell is west of first
			i2 = i1 - 1;
			j2 = j1;
		    } else if (j1 == start) {
			// first cell is on north edge
			// second cell is south of first
			i2 = i1;
			j2 = j1 + 1;
		    } else if (j1 == end) {
			// first cell is on south edge
			// second cell is north of first
			i2 = i1;
			j2 = j1 - 1;
		    } else {
			// first cell is not on an edge
			// second cell can be either north, south, west, or east of first
			dice = randInt(4);
			if (dice == 0) {
			    // west
			    i2 = i1 + 1;
			    j2 = j1;
			} else if (dice == 1) {
			    // east
			    i2 = i1 - 1;
                            j2 = j1;
			} else if (dice == 2) {
			    // south
			    i2 = i1;
                            j2 = j1 + 1;
			} else {
			    // north
			    i2 = i1;
                            j2 = j1 - 1;
			}
		    }
		    potentialWall = [[i1, j1], [i2, j2]];
		    //if (novelEdge(potentialEdge)) {
		    //if (mapIsOpen(potentialEdge)) {
		    return potentialWall;
		    //}
		    //}
		}
	    }
	}
	
	printWalls(walls) {
	    console.log("walls:");
	    for (let w of this.walls) {
		console.log(w[0] + '--' + w[1]);
	    }
	}

	printCells(cells) {
	    console.log("cells:\nposition--label");
	    for (let [key, value] of Object.entries(this.cells)) {
		console.log(key + '--' + value);
	    }
	}
	
	render(showCorners = false) {
	    if (showCorners) {
		this.renderCorners();
	    }
	}

	renderCorners() {
	    let x = 0, y = 0;
            for (let i = 0; i < this.numberCorners; i++) {
                x = i*this.cellWidth;
                for (let j = 0; j < this.numberCorners; j++) {
                    y = j*this.cellWidth;
		    this.drawCircle(x, y, 'corner');
                }
            }
	}

	drawCircle(x, y, circleType) {
            this.ctx.beginPath();
            if (circleType == 'corner') {
                this.ctx.arc(x, y, this.cornerRadius, 0, 2*Math.PI);
                this.ctx.fillStyle = this.cornerColor;
            } else if (circleType == 'player') {
                this.ctx.arc(x, y, this.playerRadius, 0, 2*Math.PI);
                this.ctx.fillStyle = this.playerColor;
            }
            this.ctx.fill();
        }

	drawLine(x1, y1, x2, y2) {
            this.ctx.beginPath();
            this.ctx.moveTo(x1, y1);
            this.ctx.lineTo(x2, y2);
            this.ctx.lineWidth = this.wallWidth;
            this.ctx.strokeStyle = this.wallColor;
            this.ctx.stroke();
        }
    }
    
    let canvas = document.getElementById('map');
    let size = 500;
    let numberCells = 8;

    let maze = new Maze(canvas, size, numberCells);
    
    /*
      let W = 10; // number of walls  
      let a, b, c, d;
      for (let w of walls) {
      a = w[0][0];
      b = w[0][1];
      c = w[1][0];
      d = w[1][1];
      drawLine((a+0.5)*D, (b + 0.5)*D, (c + 0.5)*D, (d + 0.5)*D, lineWidth, lineColor)
      }
    */
  </script>
</html>
