<html>
  <style>
    body {
	background-color: gray;
    }
    .map {
	background-color: white;
	border: solid 4px blue;
    }
  </style>
  <canvas id='map' class='map'></canvas>
  <script>
    function randInt(max) {
        return Math.floor(Math.random()*max);
    }
    
    class Maze {
	constructor(canvas, size, numberCells, numberWalls) {
	    this.canvas = canvas;
	    this.ctx = this.canvas.getContext('2d');

	    this.size = size;
	    this.canvas.width =	this.size;
            this.canvas.height = this.size;

	    this.numberCells = numberCells; // on one side
	    this.numberWalls = numberWalls;
	    
	    this.cellWidth = this.size/this.numberCells;
	    this.numberCorners = numberCells + 1;
	    
	    this.cornerRadius = 0.075*this.canvas.width/this.numberCorners;
	    this.cornerColor = 'red';
	    this.playerRadius = 5*this.cornerRadius;
	    this.playerColor = 'black';
	    this.wallWidth = 1.5*this.cornerRadius;
	    this.wallColor = 'blue';
	    this.pathWidth = this.wallWidth;
	    this.pathColor = 'green';
	    
	    this.cells = {};
	    this.walls = {};
	    this.initializeMaze();
	    this.render(true, true);
	}
	
	initializeMaze() {
	    this.initializeCells();
	    this.initializePaths();
	    //this.initializeWalls
	}
	
	initializeCells() {
	    let count = 0;
	    for (let i = 0; i < this.numberCells; i++) {
		for (let j = 0; j < this.numberCells; j++) {
		    this.cells[String(count)]  = [i, j];
		    //this.cells[label]  = [i % this.numberCells, j % this.numberCells];
		    count++;
		}
	    }
	}
	
	initializeWall(labelA, labelB) {
	    /*
	      I could check to see if this wall is already initialized, 
	      but I think that could actually be more computationally intensive.
	    */
	    //console.log(labelA, labelB);
	    this.walls[[labelA, labelB].sort().toString()] = 0;
	}
	
	initializePaths() {
	    for (let [label, position] of Object.entries(this.cells)) {
		label = Number(label);
		if (label == 0) {
		    //console.log('top left corner', label)
		    // top left corner cell
		    this.initializeWall(label, label + 1); // right
		    this.initializeWall(label, label + this.numberCells); // bottom
		} else if (label == this.numberCells - 1) {
		    //console.log('top right corner', label)
		    // top right corner cell
		    this.initializeWall(label, label - 1); // left
                    this.initializeWall(label, label + this.numberCells); // bottom
		} else if (label == this.numberCells*(this.numberCells - 1)) {
		    //console.log('bottom left corner', label)
		    // bottom left corner cell
		    this.initializeWall(label, label + 1); // right
                    this.initializeWall(label, label - this.numberCells); // top
		} else if (label == this.numberCells*this.numberCells - 1) {
		    //console.log('bottom right corner', label)
		    // bottom right corner cell
		    this.initializeWall(label, label - 1); // left
                    this.initializeWall(label, label - this.numberCells); // top
		} else if (label > 0 && label < this.numberCells - 1) {
		    //console.log('top row', label)
		    // top row minus corners
		    this.initializeWall(label, label + 1); // right
                    this.initializeWall(label, label - 1); // left
		    this.initializeWall(label, label + this.numberCells); // bottom
		} else if (label > this.numberCells*(this.numberCells - 1) && label < this.numberCells*this.numberCells - 1) {
		    //console.log('bottom row', label)
		    // bottom row minus corners
		    this.initializeWall(label, label + 1); // right
		    this.initializeWall(label, label - 1); // left
		    this.initializeWall(label, label - this.numberCells ); // top
		} else if (label % this.numberCells == 0) {
		    //console.log('left column', label)
		    // left column minus corners
		    this.initializeWall(label, label - this.numberCells); // top
                    this.initializeWall(label, label + this.numberCells); // bottom
		    this.initializeWall(label, label + 1); // right
		} else if ((label + 1) % this.numberCells == 0) {
		    //console.log('right column', label)
		    // right column minus corners
		    this.initializeWall(label, label - this.numberCells); // top
		    this.initializeWall(label, label + this.numberCells); // bottom
		    this.initializeWall(label, label - 1); // left
		} else {
		    //console.log('middle', label)
		    // in the middle
		    this.initializeWall(label, label - 1); // left
		    this.initializeWall(label, label + 1); // right
		    this.initializeWall(label, label - this.numberCells); // top
		    this.initializeWall(label, label + this.numberCells); // bottom
		}
	    }
	    /*
	    for (let count = 0; count < this.numberWalls; count++) {
		this.walls.push(this.createWall());
	    }
	    */
	}

	isCorner(i, j) {
	    // there must be a simpler way to do this, probably with modulo
	    if (i == 0 && j == 0) {
		return true; // north west corner
	    } else if (i == 0 && j == this.numberCells - 1) {
		return true; // south west corner
	    } else if (i == this.numberCells - 1 && j == 0) {
		return true; // north east corner
	    } else if (i == this.numberCells - 1 && j == this.numberCells - 1) {
		return true; // south west corner
	    } else {
		return false;
	    }
	}

	isSameCell(A, B) {
	    if (A[0] == B[0] && A[1] == B[1]) {
		return true;
	    } else {
		return false;
	    }
	}
	
	isAlreadyWall(w) {
	    // this will be deleted eventually

	    /*
	      Checks to see if w is in set of walls
	      
	      Returns true if
	      w = [[a,b], [c, d]] 
	      e = [[a,b], [c, d]]
	      OR
	      w = [[a,b], [c, d]] 
	      e = [[c, d], [a, b]]

	      Otherwise returns false
	      
	      That is, order of cells doesn't matter,
	      per the definition of edge between vertices.
	    */
	    for (let o of this.walls) {
		if (this.isSameCell(w[0], o[0]) && this.isSameCell(w[1], o[1])) {
		    return true;
		} else if (this.isSameCell(w[0], o[1]) && this.isSameCell(w[1], o[0])) {
		    return true;
		} else {
		    return false;
		}
	    }
	}
	
	mapStillOpen(newWall) {
            if (!newWall) {
		return false;
            }
	}
	
	createWall() {
	    /*
	      Creates a valid wall out of all possible walls.
	      
	      The loop chooses random wall and rejects it if
	      1) it's already in set of walls, or
	      2) it prevents a path from any cell to any other cell
	    */
	    let i1, j1; // first cell
	    let i2, j2; // second cell
	    let potentialWall;
	    let dice;
	    //let start = -1, end = N + 1;
	    let start = 0, end = this.numberCells - 1;
	    while (true) {
		i1 = randInt(end + 1) + start, j1 = randInt(end) + start;
		//i1 = randInt(end + 1) + start, j1 = randInt(end + 1) + start;
		if (!this.isCorner(i1, j1)) {
		    if (i1 == start) {
			// first cell is on west edge
			// second cell is east of first
			i2 = i1 + 1;
			j2 = j1;
		    } else if (i1 == end) {
			// first cell is on east edge
			// second cell is west of first
			i2 = i1 - 1;
			j2 = j1;
		    } else if (j1 == start) {
			// first cell is on north edge
			// second cell is south of first
			i2 = i1;
			j2 = j1 + 1;
		    } else if (j1 == end) {
			// first cell is on south edge
			// second cell is north of first
			i2 = i1;
			j2 = j1 - 1;
		    } else {
			// first cell is not on an edge
			// second cell can be either north, south, west, or east of first
			dice = randInt(4);
			if (dice == 0) {
			    // west
			    i2 = i1 + 1;
			    j2 = j1;
			} else if (dice == 1) {
			    // east
			    i2 = i1 - 1;
                            j2 = j1;
			} else if (dice == 2) {
			    // south
			    i2 = i1;
                            j2 = j1 + 1;
			} else {
			    // north
			    i2 = i1;
                            j2 = j1 - 1;
			}
		    }
		    potentialWall = [[i1, j1], [i2, j2]];
		    //if (novelEdge(potentialEdge)) {
		    //if (mapIsOpen(potentialEdge)) {
		    return potentialWall;
		    //}
		    //}
		}
	    }
	}
	
	printWalls(walls) {
	    console.log("walls:");
	    for (let w of this.walls) {
		console.log(w[0] + '--' + w[1]);
	    }
	}

	printCells(cells) {
	    console.log("cells:\nposition--label");
	    for (let [key, value] of Object.entries(this.cells)) {
		console.log(key + '--' + value);
	    }
	}
	
	render(showCorners = false, showPaths = false) {
	    if (showCorners) {
		this.renderCorners();
	    }

	    if (showPaths) {
		this.renderPaths();
	    }
	    
	    this.renderWalls();

	    this.renderCellLabels();

	    //this.renderCellAxes();
	}

	drawCircle(x, y, circleType) {
            this.ctx.beginPath();
            if (circleType == 'corner') {
                this.ctx.arc(x, y, this.cornerRadius, 0, 2*Math.PI);
                this.ctx.fillStyle = this.cornerColor;
            } else if (circleType == 'player') {
                this.ctx.arc(x, y, this.playerRadius, 0, 2*Math.PI);
                this.ctx.fillStyle = this.playerColor;
            }
            this.ctx.fill();
        }

	renderPaths() {
	    let a, b, c, d;
	    let labelA, labelB;
	    for (let [path, open] of Object.entries(this.walls)) {
		if (open) {
		    [labelA, labelB] = path.split(',');
		    a = this.cells[labelA][0];
		    b = this.cells[labelA][1];
		    c = this.cells[labelB][0];
		    d = this.cells[labelB][1];
		    this.drawLine((a+0.5)*this.cellWidth,
				  (b + 0.5)*this.cellWidth,
				  (c + 0.5)*this.cellWidth,
				  (d + 0.5)*this.cellWidth, 'path');
		}
	    }
	}

	renderCellLabels() {
	    let a, b;
	    this.ctx.font = String(this.size/this.numberCells/5) + "px Arial";
	    for (let [label, position] of Object.entries(this.cells)) {
		a = this.cells[label][0];
                b = this.cells[label][1];
		this.ctx.fillText(String(label), (a + 0.5)*this.cellWidth, (b + 0.5)*this.cellWidth);
	    }
	}

	renderCorners() {
            let x = 0, y = 0;
            for (let i = 0; i < this.numberCorners; i++) {
                x = i*this.cellWidth;
                for (let j = 0; j < this.numberCorners; j++) {
                    y = j*this.cellWidth;
                    this.drawCircle(x, y, 'corner');
                }
            }
        }

	renderWalls() {
	    let a, b, c, d;
	    let x1,x2,y1,y2;
            let labelA, labelB, tempLabel;
	    for (let [path, open] of Object.entries(this.walls)) {		
		if (!open) {
		    [labelA, labelB] = path.split(',');
		    labelA = Number(labelA);
		    labelB = Number(labelB);
		    if (labelA > labelB) {
			tempLabel = labelA;
			labelA = labelB;
			labelB = tempLabel;
		    }
		    a = this.cells[labelA][0];
                    b = this.cells[labelA][1];
                    c = this.cells[labelB][0];
                    d = this.cells[labelB][1];
		    if (a != c) {
			// vertical wall
			console.log(path,'vertical')
			x1 = c;
			y1 = b;
			x2 = c;
			y2 = d + 1;
			//this.drawLine(x1*this.cellWidth, y1*this.cellWidth, x2*this.cellWidth, y2*this.cellWidth, 'wall');
		    } else {
			// horizonal wall
			console.log(path, 'horizontal')
			x1 = a;
                        y1 = d;
                        x2 = c + 1;
                        y2 = d;
		    }
		    console.log(x1, y1, x2, y2, 'labels:', labelA, labelB)
		    this.drawLine(x1*this.cellWidth, y1*this.cellWidth, x2*this.cellWidth, y2*this.cellWidth, 'wall');
		}
	    }
	}

	drawLine(x1, y1, x2, y2, lineType) {
            this.ctx.beginPath();
            this.ctx.moveTo(x1, y1);
            this.ctx.lineTo(x2, y2);
	    if (lineType == 'wall') {
		this.ctx.lineWidth = this.wallWidth;
		this.ctx.strokeStyle = this.wallColor;
	    } else if (lineType == 'path') {
		this.ctx.lineWidth = this.pathWidth;
                this.ctx.strokeStyle = this.pathColor;
	    }
            this.ctx.stroke();
        }
    }
    
    let canvas = document.getElementById('map');
    let size = 500;
    let numberCells = 5;
    let numberWalls = 10;

    let maze = new Maze(canvas, size, numberCells, numberWalls);
  </script>
</html>
