<html>
  <style>
    body {
	background-color: gray;
    }
    .map {
	background-color: white;
	border: solid 4px blue;
    }
  </style>
  <canvas id='map' class='map'></canvas>
  <script>
    let canvas = document.getElementById('map');
    let ctx = canvas.getContext('2d');
    
    // set the canvas dimensions (length and width)
    canvas.width = 500;
    canvas.height = 500;
    
    function drawCircle(x, y, r, color) {		
	/* 
	   draws a circle on the map
	   at centered at (x, y) with
	   radius r
	*/
	ctx.beginPath();
	ctx.arc(x, y, r, 0, 2*Math.PI);
	ctx.fillStyle = color;
	ctx.fill();
    }
    
    function drawLine(x1, y1, x2, y2, width, color) {
	ctx.beginPath();
	ctx.moveTo(x1, y1);
	ctx.lineTo(x2, y2);
	ctx.lineWidth = width;
	ctx.strokeStyle = color;
	ctx.stroke();
    }
    
    let circleColor = 'red';
    let R = 3; // the radius of a circle

    function randInt(max) {
	return Math.floor(Math.random()*max);
    }

    let N = 20; // the number of cells on each side 
    let walls =	[]; // the walls between cells
    function initializeWalls(numberWalls) {
        /*
          randomly initialize map
          preserves the property that paths exist
          from all cells to all cells
        */

	for (let count = 0; count < numberWalls; count++) {
	    walls.push(createWall());
	}
    }

    function isCorner(i, j) {
	if (i == 0 && j == 0) {
	    return true; // north west corner
	} else if (i == 0 && j == N - 1) {
	    return true; // south west corner
	} else if (i == N - 1 && j == 0) {
	    return true; // north east corner
	} else if (i == N - 1 && j == N - 1) {
	    return true; // south west corner
	} else {
	    return false;
	}
    }

    function isSameCell(A, B) {
	if (A[0] == B[0] && A[1] == B[1]) {
	    return true;
	} else {
	    return false;
	}
    }

    function isAlreadyWall(w) {
	/*
	  Checks to see if w is in set of walls
	  
	  Returns true if
	  w = [[a,b], [c, d]] 
	  e = [[a,b], [c, d]]
	  OR
	  w = [[a,b], [c, d]] 
	  e = [[c, d], [a, b]]

	  Otherwise returns false
	  
	  That is, order of cells doesn't matter,
	  per the definition of edge between vertices.
	*/
	for (let o of walls) {
	    if (isSameCell(w[0], o[0]) && isSameCell(w[1], o[1])) {
		return true;
	    } else if (isSameCell(w[0], o[1]) && isSameCell(w[1], o[0])) {
		return true;
	    } else {
		return false;
	    }
	}
    }
    
    function mapStillOpen(newWall) {
        if (!newWall) {
            return false;
        }
    }
    
    function createWall() {
	/*
	  Creates a valid wall out of all possible walls.
	  
	  The loop chooses random wall and rejects it if
	  1) it's already in set of walls, or
	  2) it prevents a path from any cell to any other cell
	*/
	let i1, j1; // first cell
	let i2, j2; // second cell
	let potentialWall;
	let dice;
	//let start = -1, end = N + 1;
	let start = 0, end = N - 1;
	while (true) {
	    i1 = randInt(end + 1) + start, j1 = randInt(end) + start;
	    //i1 = randInt(end + 1) + start, j1 = randInt(end + 1) + start;
	    if (!isCorner(i1, j1)) {
		if (i1 == start) {
		    // first cell is on west edge
		    // second cell is east of first
		    i2 = i1 + 1;
                    j2 = j1;
		} else if (i1 == end) {
		    // first cell is on east edge
		    // second cell is west of first
		    i2 = i1 - 1;
                    j2 = j1;
		} else if (j1 == start) {
		    // first cell is on north edge
		    // second cell is south of first
		    i2 = i1;
                    j2 = j1 + 1;
		} else if (j1 == end) {
		    // first cell is on south edge
		    // second cell is north of first
		    i2 = i1;
                    j2 = j1 - 1;
		} else {
		    // first cell is not on an edge
		    // second cell can be either north, south, west, or east of first
		    dice = randInt(4);
		    if (dice == 0) {
			// west
			i2 = i1 + 1;
			j2 = j1;
		    } else if (dice == 1) {
			// east
			i2 = i1 - 1;
                        j2 = j1;
		    } else if (dice == 2) {
			// south
			i2 = i1;
                        j2 = j1 + 1;
		    } else {
			// north
			i2 = i1;
                        j2 = j1 - 1;
		    }
		}
		potentialWall = [[i1, j1], [i2, j2]];
		//if (novelEdge(potentialEdge)) {
		//if (mapIsOpen(potentialEdge)) {
		return potentialWall;
		//}
		//}
	    }
	}
    }

    function showWalls() {
	for (let w of walls) {
	    console.log(w[0] + '--' + w[1]);
	}
    }

    let W = 500; // number of walls
    initializeWalls(W);
    showWalls();
    
    let D = canvas.width/N; // the side length of each square cell
    
    let lineWidth = 5;
    let lineColor = 'blue';

    let x = 0, y = 0;
    for (let i = 0; i < N + 1; i++) {
	x = i*D;
	for (let j = 0; j < N + 1; j++) {
	    y = j*D;
	    drawCircle(x, y, R, circleColor);
 
	    /*
	    if (j == 0 && i < N - 1) {
		console.log();
		drawLine(x, 0, (i+1)*D, 0, lineWidth, lineColor);
	    }
	    if (i == 0 && j < N - 1) {
		drawLine(0, y, 0, (j+1)*D, lineWidth, lineColor);
	    }
	    */
	    
	}
    }

    let a, b, c, d;
    for (let w of walls) {
	/*
	  w = [[a, b], [c, d]]
	  vertical wall if a == c
	  horitontal wall if b == d 
	*/
	a = w[0][0];
	b = w[0][1];
	c = w[1][0];
	d = w[1][1];

	
	//console.log(a, b, c, d);
	//console.log((a+0.5)*D, (b + 0.5)*D, (c + 0.5)*D, (d + 0.5)*D);
	
	//drawLine(a*D, b*D, c*D, d*D, lineWidth, lineColor);
	drawLine((a+0.5)*D, (b + 0.5)*D, (c + 0.5)*D, (d + 0.5)*D, lineWidth, lineColor)
	//if (a == c) {
	//    drawLine(a)
	//}
	//drawLine(x, 0, (i+1)*D, 0, lineWidth, lineColor);
    }
  </script>
</html>
